import datetime
import os
import random
from flask import Flask, render_template
from google.cloud import datastore
import google.oauth2.id_token
from flask import Flask, render_template, request, redirect, Response
from google.auth.transport import requests
from google.cloud import storage
import local_constants

credential_path = "lukas-project.json"
os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = credential_path

app = Flask(__name__)
datastore_client = datastore.Client()
firebase_request_adapter = requests.Request() #retrieve datastore client (verify users at any stage)


#----------------------------------------------------------------------NOTES-START----------------------------------------------------------------------
"""
If the URL is called without anything after the '/'. this is called root URL.
@app.route('/')
def hello():    #Once above URL is called, this method will trigger
 return 'Hello world'   #User will see whatvever is returned

entity = datastore.Entity(key = datastore_client.key('visit'))
entity.update({'timestamp' : dt})  #update will add attributes if they are not defined in the entity.
                                    #if it already exists in the tnity, it will overwrite the value for that attribute.
datastore_client.put(entity)       #store entity in the datastore

query = datastore_client.query(kind='visit')   #query to retrieve the last number of 'visit' entities
query.order = ['-timestamp']                   #the order in which we want the entites to return
times = query.fetch(limit=limit)               #fetch 'visit' entities from the datastore to the limit of the passed in parameter in the function

def store_time(email, dt):
 entity = datastore.Entity(key = datastore_client.key('User', email, 'visit'))  #key will identify a user by an email address, second part of the key will be an autogenerated key that will be used to identify the visit of that user.
 entity.update({'timestamp' : dt})
 datastore_client.put(entity)

def fetch_times(email, limit):
 ancestor_key = datastore_client.key('User', email) #define ancestor key for the User entity with an email address
 query = datastore_client.query(kind='visit', ancestor=ancestor_key)    #only pull back the visit objects thatbhave our ancestor key set (only retrieve visit entities belonging to the user).
 query.order = ['-timestamp']
 times = query.fetch(limit=limit)
 return times

-------

def retrieveUserInfo(claims):
 entity_key = datastore_client.key('UserInfo', claims['email']) #Use email address from this 'claims' objectas the Identifier for a key for a UserInfo entity (Ties down a UserInfo object to a specific user login).
                                                                #Retreive user info from datastore
 entity = datastore_client.get(entity_key)
 return entity

def createUserInfo(claims):
 entity_key = datastore_client.key('UserInfo', claims['email']) #Create key for user info that is tied down to current user's Email.
 entity = datastore.Entity(key = entity_key) #Then it creates a UserInfo entity using that key
 entity.update({            #provides a dictionary of values to add to this UserInfo object.
  'email': claims['email'],
  'name': claims['name'],
  'creation_date': datetime.datetime.now(),
  'bool_value': True,
  'float_value': 3.14,
  'int_value': 10,
  'string_value': 'this is a sample string',
  'list_value': [1, 2, 3, 4],
  'dictionary_value': {'A' : 1, 'B': 2, 'C': 3}
 })
 datastore_client.put(entity)

def updateUserInfo(claims, new_string, new_int, new_float):
 entity_key = datastore_client.key('UserInfo', claims['email'])
 entity = datastore_client.get(entity_key)
 entity.update({
 'string_value': new_string,
 'int_value': new_int,
 'float_value': new_float
 })
 datastore_client.put(entity)

@app.route('/edit_user_info', methods=['POST'])
def editUserInfo():
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 user_info = None
 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
   new_string = request.form['string_update']      #pull back the text associated with the strings from the form
   new_int = request.form['int_update']
   new_float = request.form['float_update']
   updateUserInfo(claims, new_string, new_int, new_float)  #pass in data to function
  except ValueError as exc:
   error_message = str(exc)
 return redirect("/")

def retrieveAddresses(user_info):
 # make key objects out of all the keys and retrieve them
 address_ids = user_info['address_list']    #Pull the list of keys directly from the 'user_info' entity provided.
 address_keys = []
 for i in range(len(address_ids)):
  address_keys.append(datastore_client.key('Address', address_ids[i]))   #pull out each key from the list and create a datastore key out of it
 address_list = datastore_client.get_multi(address_keys)                #provide the list of key objects to get_multi() which will pull back the entities associated with each key.
 return address_list

"""
#----------------------------------------------------------------------NOTES-END----------------------------------------------------------------------
def createUserInfo(claims):
 entity_key = datastore_client.key('UserInfo', claims['email'])
 entity = datastore.Entity(key = entity_key)
 entity.update({
 'email': claims['email'],
 'name': claims['name'],
 })
 datastore_client.put(entity)

def retrieveUserInfo(claims):
 entity_key = datastore_client.key('UserInfo', claims['email'])
 entity = datastore_client.get(entity_key)
 return entity

def blobList(prefix):
 storage_client = storage.Client(project=local_constants.PROJECT_NAME)
 return storage_client.list_blobs(local_constants.PROJECT_STORAGE_BUCKET, prefix=prefix)

@app.route('/add_directory', methods=['POST'])
def addDirectoryHandler():
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 times = None
 user_info = None
 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
   directory_name = request.form['dir_name']
   if directory_name == '' or directory_name[len(directory_name) - 1] != '/':
    return redirect('/')
   user_info = retrieveUserInfo(claims)
   addDirectory(directory_name)
  except ValueError as exc:
   error_message = str(exc)
 return redirect('/')

@app.route('/upload_file', methods=['post'])
def uploadFileHandler():
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 times = None
 user_info = None
 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
   file = request.files['file_name']
   if file.filename == '':
    return redirect('/')
   user_info = retrieveUserInfo(claims)
   addFile(file)
  except ValueError as exc:
   error_message = str(exc)
 return redirect('/')

@app.route('/download_file/<string:filename>', methods=['POST'])
def downloadFile(filename):
 print("/download_file/" + filename)
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 times = None
 user_info = None
 file_bytes = None
 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
  except ValueError as exc:
   error_message = str(exc)
 return Response(downloadBlob(filename), mimetype='application/octet-stream')

@app.route('/open_directory/<string:filename>' + '/', methods=['POST'])
def openDirectory(filename):
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 times = None
 user_info = None
 file_list = []
 no_directories = "true"

 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
   user_info = retrieveUserInfo(claims)
   if user_info == None:
    createUserInfo(claims)
    user_info = retrieveUserInfo(claims)

   blob_list = blobList(None)
   for i in blob_list:
    if i.name[len(i.name) - 1] != '/':
     if("/" in i.name):
      print(i.name)
      full_path = i.name.split("/", 1)
      print(full_path)
      file_in_current_directory = full_path[0]
      print(file_in_current_directory)
      if(file_in_current_directory == filename):
       print(filename)
       i.name = full_path[1]

       file_list.append(i)

  except ValueError as exc:
   error_message = str(exc)

 return render_template('index.html', user_data=claims, error_message=error_message, user_info=user_info, file_list=file_list, no_directories=no_directories)

def addDirectory(directory_name):
 storage_client = storage.Client(project=local_constants.PROJECT_NAME)
 bucket = storage_client.bucket(local_constants.PROJECT_STORAGE_BUCKET)
 blob = bucket.blob(directory_name)
 blob.upload_from_string('', content_type='application/x-www-formurlencoded;charset=UTF-8')

def addFile(file):
 storage_client = storage.Client(project=local_constants.PROJECT_NAME)
 bucket = storage_client.bucket(local_constants.PROJECT_STORAGE_BUCKET)
 blob = bucket.blob(file.filename)
 blob.upload_from_file(file)

def downloadBlob(filename):
 storage_client = storage.Client(project=local_constants.PROJECT_NAME)
 bucket = storage_client.bucket(local_constants.PROJECT_STORAGE_BUCKET)
 blob = bucket.blob(filename)
 return blob.download_as_bytes()

@app.route('/back', methods=['POST'])
def back():
 return redirect('/')

@app.route('/')
def root():
 id_token = request.cookies.get("token")
 error_message = None
 claims = None
 times = None
 user_info = None
 file_list = []
 directory_list = []

 if id_token:
  try:
   claims = google.oauth2.id_token.verify_firebase_token(id_token, firebase_request_adapter)
   user_info = retrieveUserInfo(claims)
   if user_info == None:
    createUserInfo(claims)
    user_info = retrieveUserInfo(claims)

   blob_list = blobList(None)
   for i in blob_list:
    if i.name[len(i.name) - 1] == '/':
     directory_list.append(i)
    elif "/" not in i.name:
     file_list.append(i)

  except ValueError as exc:
   error_message = str(exc)

 return render_template('index.html', user_data=claims, error_message=error_message, user_info=user_info, file_list=file_list, directory_list=directory_list)

if __name__ == '__main__':
 app.run(host='127.0.0.1', port=8060, debug=True)
